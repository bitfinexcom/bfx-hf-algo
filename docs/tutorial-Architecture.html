<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Tutorial: Architecture - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AOHost.html">AOHost</a><ul class='methods'><li data-type='method'><a href="AOHost.html#aosRunning">aosRunning</a></li><li data-type='method'><a href="AOHost.html#close">close</a></li><li data-type='method'><a href="AOHost.html#connect">connect</a></li><li data-type='method'><a href="AOHost.html#getAdapter">getAdapter</a></li><li data-type='method'><a href="AOHost.html#getAO">getAO</a></li><li data-type='method'><a href="AOHost.html#getAOInstance">getAOInstance</a></li><li data-type='method'><a href="AOHost.html#getAOInstances">getAOInstances</a></li><li data-type='method'><a href="AOHost.html#getAOs">getAOs</a></li><li data-type='method'><a href="AOHost.html#loadAllAOs">loadAllAOs</a></li><li data-type='method'><a href="AOHost.html#reconnect">reconnect</a></li><li data-type='method'><a href="AOHost.html#reloadAllAOs">reloadAllAOs</a></li><li data-type='method'><a href="AOHost.html#startAO">startAO</a></li><li data-type='method'><a href="AOHost.html#stopAO">stopAO</a></li></ul></li><li><a href="AsyncEventEmitter.html">AsyncEventEmitter</a><ul class='methods'><li data-type='method'><a href="AsyncEventEmitter.html#emit">emit</a></li><li data-type='method'><a href="AsyncEventEmitter.html#off">off</a></li><li data-type='method'><a href="AsyncEventEmitter.html#on">on</a></li><li data-type='method'><a href="AsyncEventEmitter.html#onAll">onAll</a></li><li data-type='method'><a href="AsyncEventEmitter.html#onAllOnce">onAllOnce</a></li><li data-type='method'><a href="AsyncEventEmitter.html#once">once</a></li><li data-type='method'><a href="AsyncEventEmitter.html#removeAllListeners">removeAllListeners</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-AccumulateDistribute.html">AccumulateDistribute</a><ul class='methods'><li data-type='method'><a href="module-AccumulateDistribute.html#.declareChannels">declareChannels</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.declareEvents">declareEvents</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.generateOrder">generateOrder</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.generateOrderAmounts">generateOrderAmounts</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.genOrderLabel">genOrderLabel</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.genPreview">genPreview</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.getUIDef">getUIDef</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.hasIndicatorCap">hasIndicatorCap</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.hasIndicatorOffset">hasIndicatorOffset</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.hasOBRequirement">hasOBRequirement</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.hasTradeRequirement">hasTradeRequirement</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.initState">initState</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onDataManagedBook">onDataManagedBook</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onDataManagedCandles">onDataManagedCandles</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onDataTrades">onDataTrades</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onLifeStart">onLifeStart</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onLifeStop">onLifeStop</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onOrdersOrderCancel">onOrdersOrderCancel</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onOrdersOrderFill">onOrdersOrderFill</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onSelfIntervalTick">onSelfIntervalTick</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.onSelfSubmitOrder">onSelfSubmitOrder</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.processParams">processParams</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.scheduleTick">scheduleTick</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.serialize">serialize</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.unserialize">unserialize</a></li><li data-type='method'><a href="module-AccumulateDistribute.html#.validateParams">validateParams</a></li></ul></li><li><a href="module-Helpers.html">Helpers</a><ul class='methods'><li data-type='method'><a href="module-Helpers.html#~cancelAllOrdersWithDelay">cancelAllOrdersWithDelay</a></li><li data-type='method'><a href="module-Helpers.html#~cancelOrderWithDelay">cancelOrderWithDelay</a></li><li data-type='method'><a href="module-Helpers.html#~clearAllTimeouts">clearAllTimeouts</a></li><li data-type='method'><a href="module-Helpers.html#~debug">debug</a></li><li data-type='method'><a href="module-Helpers.html#~declareChannel">declareChannel</a></li><li data-type='method'><a href="module-Helpers.html#~declareEvent">declareEvent</a></li><li data-type='method'><a href="module-Helpers.html#~emit">emit</a></li><li data-type='method'><a href="module-Helpers.html#~emitAsync">emitAsync</a></li><li data-type='method'><a href="module-Helpers.html#~emitSelf">emitSelf</a></li><li data-type='method'><a href="module-Helpers.html#~emitSelfAsync">emitSelfAsync</a></li><li data-type='method'><a href="module-Helpers.html#~notifyUI">notifyUI</a></li><li data-type='method'><a href="module-Helpers.html#~submitOrderWithDelay">submitOrderWithDelay</a></li><li data-type='method'><a href="module-Helpers.html#~updateState">updateState</a></li></ul></li><li><a href="module-Iceberg.html">Iceberg</a></li><li><a href="module-MACrossover.html">MACrossover</a></li><li><a href="module-OCOCO.html">OCOCO</a></li><li><a href="module-PingPong.html">PingPong</a></li><li><a href="module-TWAP.html">TWAP</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-Architecture.html">Architecture</a></li></ul><h3>Global</h3><ul><li><a href="global.html#defineAlgoOrder">defineAlgoOrder</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Tutorial: Architecture</h1>
    

    <section>

<header>
    

    <h2>Architecture</h2>
</header>

<article>
    <h2>AO Host</h2>
<p>The <a href="AOHost.html"><code><code>AOHost</code></code></a> class provides a wrapper around the algo order system, and manages
lifetime events/order execution. Internally it utilizes an <a href="https://github.com/bitfinexcom/bfx-hf-ext-plugin-bitfinex/blob/master/lib/ao_adapter/index.js"><code>AOAdapter</code></a>
instance to communicate with the exchange API, and listens for websocket stream
events in order to update order state/trigger algo order events.</p>
<p>Execution is handled by an event system, with events being triggered by
<a href="https://github.com/bitfinexcom/bfx-hf-ext-plugin-bitfinex/blob/master/lib/ao_adapter/index.js"><code>AOAdapter</code></a>
websocket stream payloads, and the algo orders themselves.</p>
<p>To start/stop algo orders, <a href="AOHost.html#startAO"><code><code>gid = startAO(id, args)</code></code></a> and
<a href="AOHost.html#stopAO"><code><code>stopAO(gid)</code></code></a> methods are provided, with the generated
group ID (<code>gid</code>) being the same as that used for all atomic orders created by
the individual algo orders.</p>
<h2>Algo Order System</h2>
<p>Algorithmic orders are defined by an ID/Name pair, a set of meta functions
describing the order, and a set of event handlers to be triggered during the
orders lifetime/execution. A <a href="global.html#defineAlgoOrder"><code><code>defineAlgoOrder</code></code></a> helper
is provided to construct the final AO definition object:</p>
<pre class="prettyprint source lang-js"><code>const AO = defineAlgoOrder({
  id: 'some.ao.identifier',
  name: 'Descriptive AO Label',

  // meta functions describing the order/execution environment
  meta: {
    validateParams,  // validates processed parameters
    processParams,   // prepares raw parameters for execution
    declareEvents,   // declares/hooks up custom internal event handlers
    declareChannels, // declares needed data channels, to be managed by the AO host
    getUIDef,        // returns the Bitfinex Order Form definition schema
    genOrderLabel,   // constructs a label for generated atomic orders
    genPreview,      // generates preview orders for rendering in the bfx UI
    initState,       // creates the initial AO state object
    serialize,       // serializes state for DB persistence
    unserialize,     // unserializes loaded DB states for execution
  },

  events: {
    self: {
      // internal events, bound in declareEvents()
    },

    life: {
      start, // triggered on execution start, should handle initialisation
      stop,  // triggered on execution stop, should handle teardown
    },

    orders: {
      order_snapshot, // triggered upon receival of an account order snapshot
      order_new,      // triggered when a new order is opened
      order_update,   // triggered when an order is updated
      order_close,    // triggered when an order is closed
      order_fill,     // triggered on any order fill (order new/update/close)
      order_cancel,   // triggered when an order is closed via cancellation
    },

    data: {
      managedCandles, // triggered by receipt of a managed candle dataset
      managedBook,    // triggered by receipt of a managed order book
      notification,   // triggered by receipt of a notification
      candles,        // triggered by receipt of candles
      ticker,         // triggered by receipt of a ticker
      trades,         // triggered by receipt of trades
      book,           // triggered by receipt of an order book snapshot/update
    },

    errors: {
      minimum_size,   // triggered when an order fails due to being below the
                      // minimum size for its symbol; the AO may need to be stopped
    }
  }
})
</code></pre>
<h3>AO Event Handlers &amp; Helpers</h3>
<p>All event handlers receive the same arguments: <code>(instance = {}, ...args)</code>. The
instance contains two objects, <code>{ state = {}, h = {} }</code> with <code>state</code> being the
current AO state, and <code>h</code> being a helper object.</p>
<p>The provided helpers are:</p>
<ul>
<li><code>debug(str, ...args)</code> - for logging information to the console, tagged by AO GID</li>
<li><code>emitSelf(eventName, ...args)</code> - triggers an event on the 'self' section</li>
<li><code>emitSelfAsync(eventName, ...args)</code> - same as <code>emitSelf</code> but operates on next tick</li>
<li><code>emit(eventName, ...args)</code> - raw event emitter, i.e. <code>emit('life:start')</code></li>
<li><code>emitAsync(eventName, ...args)</code> - same as <code>emit</code> but operates on next tick</li>
<li><code>notifyUI(level, message)</code> - generates and sends a notification which appears on the Bitfinex UI</li>
<li><code>cancelOrderWithDelay(state, delay, order)</code> - takes current algo state, delay in ms</li>
<li><code>cancelAllOrdersWithDelay(state, delay)</code> - cancels all active atomic orders on the AO state, delay in ms</li>
<li><code>submitOrderWithDelay(state, delay, order)</code> - takes current algo state, submits a new order, delay in ms</li>
<li><code>declareEvent(instance, host, eventName, path)</code> - declares an internal AO event, see section below</li>
<li><code>declareChannel(instance, host, channel, filter)</code> - declares a required data channel, see section below</li>
<li><code>updateState(instance, update)</code> - update the current state for an AO instance</li>
</ul>
<p>For more information, refer to the <a href="module-Helpers.html"><code>helpers documentation.</code></a></p>
<h3>Custom AO Event Handlers</h3>
<p>To declare custom events to be triggered by the <a href="module-Helpers.html#~emitSelf"><code><code>emitSelf</code></code></a>
or <a href="module-Helpers.html#~emitSelfAsync"><code><code>emitSelfAsync</code></code></a> helpers, use the
<a href="module-Helpers.html#~declareEvent"><code><code>declareEvent</code></code></a> helper inside of the
<code>declareEvents</code> meta method in order to register the event names on AO startup.
For an example, see the <a href="module-Iceberg.html"><code><code>Iceberg</code></code></a> event definition handler:</p>
<pre class="prettyprint source lang-js"><code>module.exports = (instance = {}, host) => {
  const { h = {} } = instance
  const { declareEvent } = h

  // All declared events are expected to be handled on the 'self' section, but can have any path/label

  // Map self:submit_order to the 'submit_order' handler
  declareEvent(instance, host, 'self:submit_order', 'submit_order')

  // Map self:interval_tick to the 'interval_tick' handler
  declareEvent(instance, host, 'self:interval_tick', 'interval_tick')
}
</code></pre>
<p>Later, these events are triggered within other <code>Iceberg</code> event handlers, such as
<code>submit_orders</code> within the <code>life:start</code> handler:</p>
<pre class="prettyprint source lang-js"><code>module.exports = async (instance = {}) => {
  const { h = {} } = instance
  const { emitSelf } = h

  // ...

  await emitSelf('submit_orders')
}
</code></pre>
<h3>Subscribing to Data Channels</h3>
<p>To subscribe to Bitfinex websocket API data channels, use the <code>declareChannel</code>
helper within the <code>declareChannels()</code> meta method. Channel subscribe/unsubscribe
calls will be handled automatically by the AO host during execution, with the
relevant data being passed to the <code>data</code> section event handlers upon receival.
For an example, see the <code>TWAP</code> channel declaration:</p>
<pre class="prettyprint source lang-js"><code>module.exports = async (instance = {}, host) => {
  const { h = {}, state = {} } = instance
  const { args = {} } = state
  const { symbol, priceTarget } = args
  const { declareChannel } = h

  if (hasTradeTarget(args)) {
    await declareChannel(instance, host, 'trades', { symbol })
  } else if (hasOBTarget(args)) {
    await declareChannel(instance, host, 'book', {
      symbol,
      prec: 'R0',
      len: '25'
    })
  } else {
    throw new Error(`invalid price target ${priceTarget}`)
  }
}
</code></pre>
<h2>Ping/Pong Order Type</h2>
<p>Ping/pong submits multiple 'ping' orders; once a ping order fills, an associated
'pong' order is submitted.</p>
<p>Multiple ping/pong pairs can be created by specifying an order count greater
than 1, a suitable min/max ping price, and a pong distance. Multiple ping orders
will be created between the specified min/max prices, with the associated pongs
offset by the pong distance from the ping price.</p>
<p>Example:</p>
<pre class="prettyprint source lang-js"><code>await host.startAO('bfx-ping_pong', {
  symbol: 'tBTCUSD',
  amount: 0.5,
  orderCount: 5,
  pingMinPrice: 6000,
  pingMaxPrice: 6700,
  pongDistance: 300,
  submitDelay: 150,
  cancelDelay: 150,
  _margin: false,
})
</code></pre>
<h2>Iceberg Order Type</h2>
<p>Iceberg allows you to place a large order on the market while ensuring only a
small part of it is ever filled at once. By enabling the 'Excess As Hidden'
option, it is possible to offer up the remainder as a hidden order, allowing
for minimal market disruption when executing large trades.</p>
<p>Example:</p>
<pre class="prettyprint source lang-js"><code>await host.startAO('bfx-iceberg', {
  symbol: 'tBTCUSD',
  price: 21000,
  amount: -0.5,
  sliceAmount: -0.1,
  excessAsHidden: true,
  orderType: 'LIMIT',
  submitDelay: 150,
  cancelDelay: 150,
  _margin: false,
})
</code></pre>
<h2>TWAP Order Type</h2>
<p>TWAP spreads an order out through time in order to fill at the time-weighted
average price, calculated between the time the order is submitted to the final
atomic order close.</p>
<p>The price can be specified as a fixed external target, such as the top bid/ask
or last trade price, or as an explicit target which must be matched against the
top bid/ask/last trade/etc.</p>
<p>Available price targets/explicit target conditions:</p>
<ul>
<li>OB side price (top bid/ask)</li>
<li>OB mid price</li>
<li>Last trade price</li>
</ul>
<p>Example:</p>
<pre class="prettyprint source lang-js"><code>await host.startAO('bfx-twap', {
  symbol: 'tBTCUSD',
  amount: -0.5,
  sliceAmount: -0.1,
  sliceInterval: 10,
  priceDelta: 100, // max distance from price target to fulfill condition
  priceTarget: 16650,
  priceCondition: TWAP.Config.PRICE_COND.MATCH_LAST,
  tradeBeyondEnd: false,
  orderType: 'LIMIT',
  submitDelay: 150,
  cancelDelay: 150,
  _margin: false
})
</code></pre>
<h2>Accumulate/Distribute Order Type</h2>
<p>Accumulate/Distribute allows you to break up a large order into smaller
randomized chunks, submitted at regular or irregular intervals to minimise
detection by other players in the market.</p>
<p>By enabling the 'Await Fill' option, the algorithm will ensure each component
fills before submitting subsequent orders. Enabling the 'Catch Up' flag will
cause the algorithm to ignore the slice interval for the next order if previous
orders have taken longer than expected to fill, thereby ensuring the
time-to-fill for the entire order is not adversely affected.</p>
<p>The price must be manually specified as <code>limitPrice</code> for <code>LIMIT</code> order types,
or as a combination of a price offset &amp; cap for <code>RELATIVE</code> order types. <code>MARKET</code>
A/D orders execute using <code>MARKET</code> atomic orders, and offer no price control.</p>
<p>For <code>RELATIVE</code> A/D orders, the price offset &amp; cap can both be set to one of the
following:</p>
<ul>
<li>Top ask</li>
<li>Top bid</li>
<li>Orderbook mid price</li>
<li>Last trade price</li>
<li>Moving Average (configurable period, time frame, candle price)</li>
<li>Exponential Moving Average (configurable period, time frame, candle price)</li>
</ul>
<p>The period limit for moving average targets/caps is <code>240</code>, being the number of
candles returned by the Bitfinex API when subscribing to a candle data channel.</p>
<p>Example:</p>
<pre class="prettyprint source lang-js"><code>await host.startAO('bfx-accumulate_distribute', {
  symbol: 'tBTCUSD',
  amount: -0.2,
  sliceAmount: -0.1,
  sliceInterval: 10000,
  intervalDistortion: 0.20, // %
  amountDistortion: 0.20, // %
  orderType: 'RELATIVE', // MARKET, LIMIT, RELATIVE
  offsetType: 'ask',
  offsetDelta: -10,
  capType: 'bid',
  capDelta: 10,
  submitDelay: 150,
  cancelDelay: 150,
  catchUp: true, // if true & behind, ignore slice interval (after prev fill)
  awaitFill: true, // await current slice fill before continuing to next slice
  _margin: false,
})
</code></pre>
<h2>MA Crossover</h2>
<p>MA Crossover triggers either a MARKET or LIMIT order when two user-defined moving averages cross (configurable to use MA or EMA for either the long or short signals.)</p>
<p>Example:</p>
<pre class="prettyprint source lang-js"><code>await host.startAO('bfx-ma_crossover', {
  shortType: 'EMA',
  shortEMATF: '1m',
  shortEMAPeriod: '20',
  shortEMAPrice: 'close',
  longType: 'EMA',
  longEMATF: '1m',
  longEMAPeriod: '100',
  longEMAPrice: 'close',
  amount: 1,
  symbol: 'tEOSUSD',
  orderType: 'MARKET',
  action: 'Buy',
  _margin: false,
})
</code></pre>
<h2>Execution via the Bitfinex UI</h2>
<p>To execute these algo orders via the standard Bitfinex UI, see the <a href="https://github.com/bitfinexcom/bfx-hf-algo-server">bfx-hf-algo-server</a>
repo, which uploads the relevant Order Form definitions and listens for
preview/submit notifications on the bfx API to start algo orders with parameters
taken from the UI order form.</p>
</article>

</section>

    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed Mar 11 2020 02:28:40 GMT+0700 (Indochina Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>